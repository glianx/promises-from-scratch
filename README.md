## Making Promises

Promises are among the hardest concepts in JavaScript. 

To understand what happens under the hood, I decided to write my own Promise class from scratch.

### MyPromise Implementation

I wrote a fully featured `MyPromise` class in just under 300 lines of code. 

Every line of code was generated by me, not LLMs. The class includes:

- Full implementation of the Promise/A+ specification
- All 8 static methods (`resolve`, `reject`, `all`, `allSettled`, `any`, `race`, `withResolvers`, `try`)
- Robust error handling with proper propagation
- Microtask queue implementation for proper execution timing
- Comprehensive test suite to verify behavior against native Promises

### Key Features

- **Promise Chaining**: Properly implemented `.then()` method that returns a new promise
- **Error Handling**: Complete `.catch()` implementation with proper error propagation
- **Cleanup**: `.finally()` method that works correctly in all scenarios
- **Static Methods**: All Promise static methods with correct behavior

### Test Suite

The implementation includes extensive tests that verify:

- Basic promise resolution and rejection
- Promise chaining with multiple `.then()` calls
- Error propagation through promise chains
- Edge cases in `.finally()` behavior
- All static methods working correctly

### Learning Resources

I've collected notes in the `js.info` directory that document my learning process and provide reference material on Promise behavior.

### Why Build a Custom Promise?

Implementing a Promise from scratch has been an invaluable learning experience that helped me:

1. Understand the event loop and microtask queue
2. Master asynchronous programming patterns
3. Learn how error handling works in asynchronous code
4. Appreciate the elegance of the Promise design pattern

## Running the Tests

To run the tests for the MyPromise implementation:

```bash
node myPromise/testMyPromise.js
```
